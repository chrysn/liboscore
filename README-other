thigns that should go into the documentation somewhere:

This library occasionally asks the application to carry around data in fixed-size structs
rather than giving the minimum size required for this particular tasks.
For example, stored keys are handled as a union,
and ``osc_requestid_t`` may contain something similar.
This is done not only for simplicity and to avoid dynamic memory management,
but primarily to keep low the risks associated with crypto agility.
Were those data structures dependent on the used algorithm,
then memory exhaustion in production conditions
may only trigger when the cipher suite is changed
-- which is usually the worst moment to have surprises.

On thread safety:
The data structures used in this library are not synchronized on their own;
no two functions may operate concurrently on the same message or the same security context simultaneously.
Messages under construction keep a reference to their context; their interaction with the context during operations that don't take a context reference again are read-only on invariant properties of the context. [define]
It is up to the application to place suitable locking around them if necessary.
The library does not use any global state,
so it is safe to call functions of the library concurrently,
as long as they do not act on the same pointers / objects.

especially on contexts: context has to survive with unmodified "basics" (iv/key, what precisely?) while being re-used for a single message.
offer killing a context by having a LL of in-use messages? means every created message can only ever be used with its context and needs to be freed from its context.



Asserts
-------

Any `assert` calls are used to verify internal invariants, and to help find the
issue if any such invariant is not upheld. Internal invariants here include the
behavior of the backend implementation. Given we don't get much in terms of
guarantees from C on outside influence, asserts may assume that no outside code
manipulated members declared private in the documentation, and that liboscore's
structs are always used with proper initialization. They may not assume the
validity of any other arguments, especially not sizes passed to liboscore
functions.

Production builds of the library may run with `NDEBUG` set (making all asserts
a no-op), or even in assertion modes where the trigger condition leads to a
branch declared unreachable. Using `assert` is encouraged in places where the
compiler may produce more efficient code from knowing that the condition is not
hit. (With assertions enabled, the condition is checked and the trailing code
can rely on it to be true. With unreachability indication, the condition is not
checked and the trailing code can still rely. With assertions just elided, the
compiler might create suboptimal code, but probably still better than with
assertions enabled; see [Assertions are Pessimistic, Assumptions are
Optimistic](]https://blog.regehr.org/archives/1096) for a few numbers on how
that may turn out).

An assertion triggering in released code is considered a severe bug (either in
liboscore itself or the backend).

(Using a dedicated OSCORE_ASSERT macro for easier overriding is being
considered).

Pointers
--------

In user-facing operations, this library takes a defensive stance at pointers in
memory slices.

Pointers to memory read are expected to possibly be NULL when zero length reads
are performed on them. Pointers handed out are never NULL (unless NULL is
explicitly documented as a sentinel value) and always valid, even if expected
to be used zero times.

(This is to mitigate the widespread unawareness of developers about the
requirements of `memcpy` and similar functions, which require valid pointers. A
careless `append_option(msg, NULL, 0);` could otherwise introduce undefined
behavior).
